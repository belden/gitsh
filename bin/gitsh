#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;

my %args;
GetOptions(
  'command=s'     => \$args{command},
  'debug'         => \$args{debug},
  'git-root=s'    => \(my $git_root),
);

chdir($git_root) if $git_root;

if ($args{command}) {
  $args{command} = join ' ', $args{command}, @ARGV;
}

my $gitsh = Gitsh->new(%args);
$gitsh->go;

{
  use strict;
  use warnings;
  package Gitsh;

  sub safe_eq { no warnings; return shift eq pop }

  sub new {
    my ($class, %args) = @_;
    return bless {
      args    => \%args,
      '$?'    => 0,
      command => $args{command},
      debug   => $args{debug} || 0,
      history => [],
      dirstack => [],
      env => +{
        GITSH_VERBOSE => 0,
        GITSH_DEBUG   => 0,
        GITSH_SHOW_HISTORY_ON_EXIT => 0,
      },
    }, $class;
  }

  sub go {
    my $self = shift;

    $self->restart_under_debugger if $self->{debug};

    my $keep_running = 1;
    $|++;
    while ($keep_running) {
      my $command = $self->_get_command;
      ($keep_running, $self->{'$?'}) = $self->dispatch($command);
    }

    $self->finalize;
    CORE::exit($self->{'$?'});
  }

  sub _debug {
    my ($self, @target) = @_;
    if ($self->{env}{GITSH_DEBUG}) {
      require Data::Dumper;
      print(STDERR Data::Dumper::Dumper(\@target));
    }
  }

  sub __install {
    my ($self) = @_;
    print(STDOUT $_) foreach $self->_shell(qq(make -C $ENV{HOME}/code/gitsh install > /dev/null));
    print(STDOUT "gitsh: restarting\n");
    $self->restart;
  }

  sub examine {
    my ($self) = @_;
    $self->_debug($self);
    return (1, 0);
  }

  sub _get_command {
    my ($self) = @_;

    my $command;
    if ($self->{command}) {        # we were invoked as `gitsh --command blah`
      $command = delete $self->{command}; # your wish is my command
      $self->{command} = 'exit';          # prep for exit on next entry here
    } else {
      print STDOUT 'dev@t1-dev:adama¿¡ ';
      $command = <>;

      if (!defined $command) {  # assume user hit ^D (that's how I got here anyway)
        print STDOUT "\n";      # exit to shell is weird without this newline
        $command = 'exit';
      } else {
        chomp $command;
      }
    }

    $self->add_history($command) unless $command eq 'exit';
    my $parse = $self->parse($command);
    return $parse;
  }

  sub add_history {
    my ($self, $command_line) = @_;
    push @{$self->{history}}, $command_line;
  }

  sub dispatch {
    my ($self, $command) = @_;
    my $handler = $self->dispatch_map($command);
    return $handler->();
  }

  sub _error_builder {
    my ($self, $message_builder) = @_;
    return sub {
      my ($self, $command) = @_;
      print STDERR $message_builder->($self, $command);
      return (1, 1);
    };
  }

  sub dispatch_map {
    my ($self, $parse) = @_;

    my $handler = $self->can($parse->{command}) ||
      $self->_error_builder(sub {
        my ($self, $command) = @_;
        return "$command->{command}: command not found\n";
      });

    if ($self->{env}{GITSH_DEBUG} && $parse->{command} =~ m{^_}) {
      return sub {
        my @g = $self->$handler($parse);
        local $self->{env}{GITSH_DEBUG} = 1;
        $self->_debug(\@g);
        return (1, 0);
      };
    } else {
      return sub {
        $self->$handler($parse);
      };
    }
  }

  sub _expand_alias {
    my ($self, $action) = @_;
    return $self->{aliases}{$action} || $action;
  }

  sub parse {
    my ($self, $command) = @_;

    my ($action, @args) = split /\s+/, $command;
    $action = $self->_expand_alias($action);

    # split path-looking-things into [branch,file] tuples
    my $branches = join '|', map { $_->{name} } $self->_ls;
    foreach (@args) {
      if ($_ =~ m{^($branches)/(.+)$}) {
        $_ = Gitsh::branch->new(branch => $1, file => $2);
      }
    }

    return +{
      command => $action,
      args => \@args,
      orig => $command,
    };
  }

  sub alias {
    my ($self, $command) = @_;

    if ($command->{args}[0]) {
      if (my ($alias_key, $alias_value) = $command->{args}[0] =~ m{^([^=]+)=(.+)$}) {
        ($alias_value) =~ m{^'?(.*)'?$};
        $self->{aliases}{$alias_key} = $alias_value;
      } else {
        # error handling if we didn't match, perhaps warn what we expect an alias to look like
      }
    } else {
      $self->_pretty_print_hash($self->{aliases}, 'alias ');
    }
    return (1, 0);
  }

  sub unalias {
    my ($self, $command) = @_;

    if (defined(my $alias_key = $command->{args}[0])) {
      delete $self->{aliases}{$alias_key};
    }
    return (1, 0);
  }

  sub echo {
    my ($self, $command) = @_;

    if ($command->{args}[0] eq '$?' && 1 == @{$command->{args}}) { # echo $?
      print STDOUT $self->{'$?'}, "\n";
    } else { # just echo
      (my $to_echo = $command->{orig}) =~ s{^$command->{command} }{};
      print STDOUT $to_echo, "\n";
    }

    return (1, 0);
  }

  sub exit {
    return (0, 0);
  }

  sub restart {
    my ($self, $command) = @_;
    if (safe_eq($command->{args}[0], '--debug')) {
      $self->restart_under_debugger;
    } else {
      exec("$0");
    }
    die "restart: $!\n";
  }

  sub _ls {
    my ($self) = @_;
    return map {
      chomp;
      my ($active, $name) = $_ =~ m{^(?:([* ]) )(.+)$};
      +{
        name => $name,
        is_active => $active eq '*' ? 1 : 0,
      },
    } $self->_git('branch');
  }

  sub _git {
    my ($self, @args) = @_;
    return $self->_shell('git', @args);
  }

  sub _shell {
    my ($self, @args) = @_;

    my ($command) = $args[0] =~ m{^(\S+)};
    chomp(my $helper = `which gitsh-$command-helper`);
    if ($helper) {
      $args[0] = $helper;
    }

    $self->_debug(@args);
    return qx{@args};
  }

  sub style {
    my ($self, $color, $characters) = @_;
    my %ansi = (
      green => "\e[02;32m",
      reset => "\e[0m",
    );
    return sprintf '%s%s%s', $ansi{$color}, $characters, $ansi{reset};
  }

  sub export {
    my ($self, $command) = @_;

    my %env =
    map {
      my ($k, $v) = split /=/, $_;
      ($k => $v);
    }
    map { split(/\s+/, $_) }
    @{$command->{args}};

    @{$self->{env}}{keys %env} = values %env;
    return (1, 0);
  }

  sub env {
    my ($self, $command) = @_;
    $self->_pretty_print_hash($self->{env}, '');
    return (1, 0);
  }

  sub _pretty_print_hash {
    my ($self, $hash, $prefix) = @_;
    foreach my $k (sort { $a cmp $b } keys %$hash) {
      print(STDOUT "$prefix$k=$hash->{$k}\n");
    }
    return (1, 0);
  }

  sub ls {
    my ($self, $command) = @_;
    foreach my $branch ($self->_ls) {
      my $name = $branch->{is_active}
        ? $self->style(green => $branch->{name})
        : $branch->{name};
      my $active = $branch->{is_active}
        ? '*'
        : ' ';
      print(STDOUT "$active $name\n");
    }
    return (1, 0);
  }

  sub _pwd {
    my ($self) = @_;
    my ($branch) = grep { $_->{is_active} } $self->_ls;
    return $branch;
  }

  sub pwd {
    my ($self, $command) = @_;
    my $cwd = $self->_pwd;
    print(STDOUT "$cwd->{name}\n");
    return (1, 0);
  }

  sub _cd {
    my ($self, $dest) = @_;
    $self->_git('checkout', $dest);
  }

  sub cd {
    my ($self, $command) = @_;
    my $ok = 0;

    my $dest = $command->{args}[0];
    push @{$self->{dirstack}}, {
      branch => $self->_pwd,
    };
    $self->_cd($dest);
    return (1, $ok);
  }

  sub cat {
    my ($self, $command) = @_;
    my ($file) = grep { ref($_) && $_->isa('Gitsh::branch') } @{$command->{args}};
    if ($file) {
      print(STDOUT $self->_git('show', "$file->{branch}:$file->{file}"));
    } else {
      print(STDOUT $self->_shell('cat', @{$command->{args}}));
    }
    return (1, 0);
  }

  sub unzip (&@) {
    my $c = shift;
    my ($l, $r) = ([], []);
    foreach (@_) {
      my $ar = $c->() ? $l : $r;
      push @$ar, $_;
    }
    return ($l, $r);
  }

  sub diff {
    my ($self, $command) = @_;

    my ($args, $opts) = unzip { ref($_) eq 'Gitsh::branch' } @{$command->{args}};
    my @files = map { "$_->{branch}:$_->{file}" } @$args;
    if (@files == 2) {
      print(STDOUT $self->_shell('diff', @$opts, @files[0,1]));
    } elsif (grep { /\.\./ } @$opts) {
      my ($diff_spec, $diff_opts) = unzip { $_ =~ m{\.\.} } @$opts;
      print(STDOUT $self->_git('diff', @$diff_opts, @$diff_spec));
    }
    return (1, 0);
  }

  sub mkdir {
    my ($self, $command) = @_;

    my $cwd = $self->_pwd;
    my $dest = $command->{args}[0];
    $dest =~ s{^(?!gitsh-)}{gitsh-};
    my $output = $self->_git('checkout', '-b', $dest);
    print $output if $output;

    my $error = 0;
    if ($cwd eq $self->_pwd) {
      $error = 1;
    } else {
      $self->_cd($cwd);
    }
    return (1, $error);
  }

  sub rmdir {
    my ($self, $command) = @_;

    my $target = $command->{args}[0];
    # the typo is a deliberate "check yourself before you wreck yourself"
    if (! $self->{env}{GITSH_ALLOW_DANGERNUS_ACTIONS}) {
      print(STDERR "rmdir $target: refusing to run without GITSH_ALLOW_DANGEROUS_ACTIONS set\n");
      return (1, 0);
    } else {
      delete $self->{env}{GITSH_ALLOW_DANGERNUS_ACTIONS};
      print(STDOUT $self->_git('branch', '-D', $target));
    }
  }

  sub restart_under_debugger {
    my ($self) = @_;

    delete $self->{args}{debug};

    my @args;
    while (my ($flag, $value) = each %{$self->{args}}) {
      push @args, "--$flag";
      push @args, $value if defined $value;
    }

    exec("$^X -d $0 @args");
    die "couldn't restart with debugger support, yo\n";
  }

  sub history {
    my ($self, $command) = @_;

    if ($command || $self->{env}{GITSH_SHOW_HISTORY_ON_EXIT}) {
      my $h = 1;
      foreach (@{$self->{history}}) {
        print(STDOUT "$h    $_\n");
        $h++;
      }
    }

    return (1, 0);
  }

  sub finalize {
    my ($self) = @_;
    $self->history;
    return (1, 0) if wantarray;
    return;
  }
}

{
  use strict;
  use warnings;
  package Gitsh::branch;

  sub new {
    my ($class, %args) = @_;
    return bless +{
      branch => $args{branch},
      file   => $args{file},
    }, $class;
  }

  1;
}
